"""
Author: Kole Phillips

Using the CSV files generated by slope_calcs.py, summarizes the slope and breakpoint
metrics using boxplots.

Usage: python metric_boxplots.py
"""

import matplotlib.pyplot as plt
import pandas as pd
from sys import argv


if __name__ == '__main__':
    # The studies which have already been processed by
    studies = [('victoria', 1), ('vancouver', 1), ('saskatoon', 1), ('montreal', 1)]

    # Load in the CSV files generated by slope_calcs.py
    all_data = {}
    for city, wave in studies:
        all_data[(city, wave)] = {}
        for cycle in [0, 1, 2, 4, 8]:
            in_fname = 'pa_specificity_' + city + '_' + str(wave) + '_skip-' + str(cycle) + '-minutes.csv'
            all_data[(city, wave)][cycle] = pd.read_csv(in_fname)

    # represents the r-squared value of a participant
    rs = pd.DataFrame()
    # Used to keep track of which city a participant was from to differentiate them when plotting
    city_col = []
    for slope_num in ['1', '2', '3', '4']:
        slope_label = '4-seg_slope_' + slope_num
        # Used so that the pandas groupby and boxplot functions can easily handle most of the plotting
        box_df = pd.DataFrame()
        # cycle refers to the number of minutes overwritten in each cycle
        for cycle in [0, 1, 2, 4, 8]:
            cycle_data = []
            cycle_rs = []
            for city, wave in studies:
                data = all_data[(city, wave)][cycle]
                cycle_data = cycle_data + data[slope_label].tolist()
                # We only want one copy of the r-squared values
                if slope_num == '1':
                    cycle_rs = cycle_rs + data['4-seg_r_square'].tolist()
                # Only add to the city column once for each file
                if cycle == 0 and slope_num == '1':
                    city_col = city_col + [city for _ in data]
            box_df[cycle] = cycle_data
            box_df['city'] = city_col
            if slope_num == '1':
                rs[cycle] = cycle_rs
        # Create boxplot for slopes 1-4
        box_df.groupby('city').boxplot(grid=False)
        plt.xticks(list(range(1, 6)), [0, 1, 2, 4, 8])
        if slope_num == '4':
            plt.ylim(top=0.05, bottom=-0.2)
        plt.suptitle('Slope ' + slope_num)
        plt.xlabel('Skipped Cycles')
        plt.ylabel('Slope')
        plt.savefig('grouped_counts_slope_' + slope_num + '_boxplot.png')
        plt.close()

    for b in ['1', '2', '3', 'tail']:
        if b == 'tail':
            bp = '4-seg_tail'
        else:
            bp = '4-seg_breakpoint_' + b
        box_df = pd.DataFrame()
        for cycle in [0, 1, 2, 4, 8]:
            cycle_data = []
            for city, wave in studies:
                data = all_data[(city, wave)][cycle]
                cycle_data = cycle_data + data
            box_df[cycle] = cycle_data
        # Create boxplots for the three breakpoints, as well as the tail
        box_df['city'] = city_col
        box_df.groupby('city').boxplot(grid=False)
        plt.xticks(list(range(1, 6)), [0, 1, 2, 4, 8])
        plt.suptitle('Breakpoint ' + b)
        plt.xlabel('Skipped Cycles')
        plt.ylabel('Breakpoint')
        plt.savefig('grouped_counts_breakpoint_' + b + '_boxplot.png')
        plt.close()
    # Create a boxplot for the distributions' tails
    rs['city'] = city_col
    rs.groupby('city').boxplot(grid=False)
    plt.xticks(list(range(1, 6)), [0, 1, 2, 4, 8])
    plt.suptitle('R Squared')
    plt.ylim(top=1.01)
    plt.xlabel('Skipped Cycles')
    plt.ylabel('R Squared')
    plt.savefig('grouped_rsquare_boxplot.png')
    plt.close()


